- [TOP](./firestore_index.md)
- [このメモについて](../README.md)


# インデックスを過剰に使用しない。
* https://firebase.google.com/docs/firestore/best-practices?hl=ja#indexes
* インデックスの数が多すぎると、書き込みレイテンシが増加し、インデックス エントリのストレージ コストが増加する可能性がある。
* 読み取りレートや書き込みレートが高いアプリケーションの場合、タイムスタンプのように単調に増加する値を持つフィールドにインデックスを作成すると、レイテンシに影響を与えるホットスポットが生じる可能性がある。

# インデックス
* Firestoreでは、where等によるフィルタや並び替えでインデックスを使う。
* クエリを実行したときに必要なインデックスが存在しないとエラーになる。
* 単一フィールドであれば、自動的にインデックスが作成される。
* インデックス除外によって自動インデックス設定されないように指定することもできる。
* インデックスはストレージ費用の対象。

# インデックス登録の具体例
* https://firebase.google.com/docs/firestore/query-data/index-overview?hl=ja#indexing_example

# 単一フィールドインデックス
* 特定の 1 つのフィールドを含む、コレクション内のすべてのドキュメントの並べ替え済みマッピングを保持
* 単一フィールドインデックスの各エントリには、ドキュメント内の特定のフィールドの値と、そのドキュメントのデータベース内での位置が記録
## 自動インデックス
* デフォルトでは、Cloud Firestore はドキュメント内のフィールドおよびマップ内のサブフィールドごとに単一フィールド インデックスを自動的に維持。（データベース全体の自動インデックス設定）
* Cloud Firestore では単一フィールド インデックスに次のデフォルト設定が使用
    * 配列でもなくマップでもないフィールドに対しては、コレクションのスコープを使用する2 つの単一フィールド インデックス（1 つは昇順モード、1 つは降順モード）が定義
    * マップ フィールドに対しては、マップ内の配列ではない、およびマップではない各サブフィールドごとに、コレクションのスコープを使用する 1 つの昇順インデックスと 1 つの降順インデックスが作成
    * ドキュメント内の配列フィールドに対しては、スコープがコレクションのスコープで、インデックスモードが配列の内容のインデックスが作成、維持される
    * コレクショングループのスコープがある単一フィールド インデックスは、デフォルトでは維持されない
## 単一フィールド インデックス除外
* 単一フィールドインデックス除外を作成することで、自動インデックス設定からフィールドを除外
    * インデックス除外は、データベース全体の自動インデックス設定より優先
* 除外は自動インデックス設定にのみ適用される。単一フィールド インデックスから除外したフィールドでも、複合インデックスの一部としてインデックスを作成できる。
* 除外すると、自動インデックス設定によって本来は無効になる単一フィールド インデックスを有効にしたり、自動インデックスによって本来は有効になる単一フィールド インデックスを無効にできる。
* マップのサブフィールドの除外設定の優先順位
    * 自身の除外設定、親の除外設定、データベース全体の自動インデックス設定の順

# 複合インデックス
* インデックスを作成するフィールドの順序付きリストに基づいて並べ替えられた、コレクション内のすべてのドキュメントのマッピングが格納
* 可能なフィールドの組み合わせの数が多くなるため、単一フィールド インデックスの場合とは異なり、複合インデックスの自動作成はされない。
* インデックスでサポートされていないクエリを試行するたびに、Cloud Firestore はリンクが含まれたエラー メッセージを返す。
* そのリンク先にアクセスすることによって、不足しているインデックスを作成できる。

# インデックス モード
* 昇順
    * <、<=、==、>=、>、!=、in、not-in の各クエリ句の使用と、そのフィールド値に基づいた結果の並べ替え（昇順）がサポート
* 降順
    * <、<=、==、>=、>、!=、in、not-in の各クエリ句の使用と、そのフィールド値に基づいた結果の並べ替え（降順）がサポート
* 配列の内容
    * フィールドでの array-contains クエリ句と array-contains-any クエリ句の使用がサポート

# クエリのスコープ
* コレクションのスコープ
    * Cloud Firestore では、デフォルトでコレクションのスコープがあるインデックスが作成
    * 単一のコレクションから結果を返すクエリがサポート
* コレクション グループのスコープ
    * 同じコレクション ID があるすべてのコレクションが含まれる。
        * ルートにあるコレクションでもサブコレクションでも、同じコレクションIDであればすべて含まれる。
    * コレクショングループクエリを実行するために必要
    * 例
        * https://firebase.google.com/docs/firestore/query-data/index-overview?hl=ja#queries_supported_by_collection_group_indexes

# __name__フィールド
* __name__フィールドの値は、ドキュメントの完全なパス
* 各インデックスの並び替え済インデックスは、インデックス モードによる並び替えに加えて、最終的に__name__フィールドによって並び替えされたもの。
* したがって同じ値のフィールドであれば、順番は__name__フィールドにもとづくものとなる。
* なお、__name__フィールドの昇順・降順については、そのインデックス定義の最後のフィールドの昇順・降順に従う。

# インデックスのマージ
* マージ機能を活用することで、インデックスサイズを減らすことができる。
* https://firebase.google.com/docs/firestore/query-data/index-overview?hl=ja#document

# インデックスエントリの数
* カウントの例
* https://firebase.google.com/docs/firestore/query-data/index-overview?hl=ja#index_entries

# インデックスの上限
* 複合インデックスの最大数
    * 200
* 単一フィールド構成の最大数 
    * これは「除外」とか「TTL」の設定という意味?（自動インデックス設定されたものはカウントされない想定）
    * 200
    * インデックスの除外の個数は１つのデータベースあたり200個までとここにも書いてある。
        * https://firebase.google.com/docs/firestore/solutions/index-map-field?hl=ja
* ドキュメントごとのインデックス エントリの最大数
    * 40000
* 複合インデックス内のフィールドの最大数
    * 100
* その他はリンク参照
    * https://firebase.google.com/docs/firestore/query-data/index-overview?hl=ja#indexing_limits

# 単一フィールド除外を追加したほうがいい場合
* https://firebase.google.com/docs/firestore/query-data/index-overview?hl=ja#indexing_best_practices
* ほとんどのアプリでは、自動インデックス作成とエラーメッセージのリンクを使用してインデックスを管理できる。ただし、以下のケースについては、単一フィールド除外を追加したほうがいい場合がある
    * 大きな文字列フィールド、大規模な配列フィールドまたはマップ フィールド
    * TTL フィールド
    * 等

# インデックスの管理
* https://firebase.google.com/docs/firestore/query-data/indexing?hl=ja

