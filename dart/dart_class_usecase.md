[TOP(About this memo))](../README.md) > [一覧](./README.md) >


# 注
* 本メモは IMO(In my opinion)となる。


#  拡張, 実装, class修飾子の使い分け

## classの修飾子とmixinの使い分け
![](./svg/class_usecase/class_judge.drawio.svg)

* 派生クラスのプロパティ
    * 派生クラスに持たせたいプロパティが複数のパターンがある場合、以下の方法を使い分ける。
    * パターン分のクラスを複数用意して、用途に応じたクラスを継承させる方法
    * 親クラスの各プロパティをnullableとして継承する側で取捨選択させる方法(想定外のプロパティの組み合わせはassertによってエラーとする)

## extends, with, implementsの使い分け
| | コンストラクタの再利用| 多重継承・実装 | 列挙型からの利用 | 主な用途 | 主な用途(テスト) |
|---|---|---|---|---|---|
|extends| o | x | x|class利用時(interface以外) | テスト対象のスタブ(モック)化 |
|implements| o | o | o |interface class利用時 | テスト対象のスタブ(モック)化<br/>※プライベートコンストラクタとなっていて継承できないもの |
|with| x | o | o | mixin利用時 | - |

## 列挙型の活用
* 利用可能なら積極的に使いたい。
* メリット
    * 羅列（switchによる網羅的な分岐、valuesで網羅的な処理ができる）
    * インスタンス生成不要でconst値として使える
* 利用できないケース
    * 親クラスをextendsした機能が必要な場合
        * 例えば、あるbase class(implementsができない)を継承したenum、といった用途には利用できない。
    * 定数以外の引数が必要な場合

## too muchな継承の利用方法
* 極端な例ではあるが、下記のような継承の利用は冗長となる。
```dart
class ScreenA {void checkAuth(){/**/};}
class ScreenB extends ScreenA { someFunc(){ super.checkAuth(); } }
```
* デメリットとして
    * 本来再利用したい機能以外の依存関係ができてしまう
    * 認証機能の責務を分離する機会を逃している
* 例えば別クラスとして外出しする方が良いだろう
```dart
class ScreenA(Auth auth) {/**/}
class ScreenB(Auth auth) {/**/}
```


# 責務の分離
* 責務の分離は下記のような方法があり、それぞれ用途によって使い分けることが良いだろう。

|手段|特徴|分離したAPIの呼び出し可能範囲|スタブ化|主な用途|
|-|-|-|-|-|
|移譲|・依存先の具象が１つ|インスタンス化された任意の場所|x|・１つの具象に依存しテスト時のスタブ化が不要なもの|
|移譲(インジェクション)|・依存先の具象が不特定<br/>・インジェクションする為のコードが増える|インスタンス化された任意の場所|o|・テスト時にスタブ化やテストオブジェクトを渡したいもの<br/>・不特定多数の具象の可能性があるもの(パッケージの開発時等)|
|mixinとして分離|・mixin側でon句によって特定のクラスの機能を利用できる|withしたクラスのみ|x|・特定の目的のクラスのみが利用する機能<br/>・特定のクラスの機能を前提にした機能|
|staticメソッドや関数<br/>として分離|・任意の場所でサジェストに含まれる|任意の場所|x|・副作用の無いユーティリティ系の機能<br/>・アプリケーション・ライブラリの初期設定やエントリポイントとなる関数|
